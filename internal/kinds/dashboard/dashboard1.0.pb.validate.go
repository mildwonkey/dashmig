// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: dashboard/dashboard1.0.proto

package dashboard

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on DynamicValue with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DynamicValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DynamicValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DynamicValueMultiError, or
// nil if none found.
func (m *DynamicValue) ValidateAll() error {
	return m.validate(true)
}

func (m *DynamicValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msgpack

	// no validation rules for Json

	if len(errors) > 0 {
		return DynamicValueMultiError(errors)
	}

	return nil
}

// DynamicValueMultiError is an error wrapping multiple validation errors
// returned by DynamicValue.ValidateAll() if the designated constraints aren't met.
type DynamicValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DynamicValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DynamicValueMultiError) AllErrors() []error { return m }

// DynamicValueValidationError is the validation error returned by
// DynamicValue.Validate if the designated constraints aren't met.
type DynamicValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DynamicValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DynamicValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DynamicValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DynamicValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DynamicValueValidationError) ErrorName() string { return "DynamicValueValidationError" }

// Error satisfies the builtin error interface
func (e DynamicValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDynamicValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DynamicValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DynamicValueValidationError{}

// Validate checks the field values on Dashboard with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Dashboard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Dashboard with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DashboardMultiError, or nil
// if none found.
func (m *Dashboard) ValidateAll() error {
	return m.validate(true)
}

func (m *Dashboard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Editable

	if all {
		switch v := interface{}(m.GetGraphTooltip()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DashboardValidationError{
					field:  "GraphTooltip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DashboardValidationError{
					field:  "GraphTooltip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGraphTooltip()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DashboardValidationError{
				field:  "GraphTooltip",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPanels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  fmt.Sprintf("Panels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  fmt.Sprintf("Panels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DashboardValidationError{
					field:  fmt.Sprintf("Panels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.Uid != nil {
		// no validation rules for Uid
	}

	if m.Title != nil {
		// no validation rules for Title
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Revision != nil {
		// no validation rules for Revision
	}

	if m.GnetId != nil {
		// no validation rules for GnetId
	}

	if m.Style != nil {
		// no validation rules for Style
	}

	if m.Timezone != nil {
		// no validation rules for Timezone
	}

	if m.Time != nil {

		if all {
			switch v := interface{}(m.GetTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Time",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Time",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DashboardValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Timepicker != nil {

		if all {
			switch v := interface{}(m.GetTimepicker()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Timepicker",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Timepicker",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimepicker()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DashboardValidationError{
					field:  "Timepicker",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.FiscalYearStartMonth != nil {
		// no validation rules for FiscalYearStartMonth
	}

	if m.LiveNow != nil {
		// no validation rules for LiveNow
	}

	if m.WeekStart != nil {
		// no validation rules for WeekStart
	}

	if m.Refresh != nil {
		// no validation rules for Refresh
	}

	if m.SchemaVersion != nil {
		// no validation rules for SchemaVersion
	}

	if m.Version != nil {
		// no validation rules for Version
	}

	if m.Templating != nil {

		if all {
			switch v := interface{}(m.GetTemplating()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Templating",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Templating",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTemplating()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DashboardValidationError{
					field:  "Templating",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Annotations != nil {

		if all {
			switch v := interface{}(m.GetAnnotations()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Annotations",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Annotations",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAnnotations()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DashboardValidationError{
					field:  "Annotations",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Links != nil {

		if all {
			switch v := interface{}(m.GetLinks()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Links",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Links",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLinks()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DashboardValidationError{
					field:  "Links",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Snapshot != nil {

		if all {
			switch v := interface{}(m.GetSnapshot()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Snapshot",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DashboardValidationError{
						field:  "Snapshot",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSnapshot()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DashboardValidationError{
					field:  "Snapshot",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DashboardMultiError(errors)
	}

	return nil
}

// DashboardMultiError is an error wrapping multiple validation errors returned
// by Dashboard.ValidateAll() if the designated constraints aren't met.
type DashboardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DashboardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DashboardMultiError) AllErrors() []error { return m }

// DashboardValidationError is the validation error returned by
// Dashboard.Validate if the designated constraints aren't met.
type DashboardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DashboardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DashboardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DashboardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DashboardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DashboardValidationError) ErrorName() string { return "DashboardValidationError" }

// Error satisfies the builtin error interface
func (e DashboardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDashboard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DashboardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DashboardValidationError{}

// Validate checks the field values on DashboardCursorSync with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DashboardCursorSync) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DashboardCursorSync with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DashboardCursorSyncMultiError, or nil if none found.
func (m *DashboardCursorSync) ValidateAll() error {
	return m.validate(true)
}

func (m *DashboardCursorSync) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Value != nil {
		// no validation rules for Value
	}

	if len(errors) > 0 {
		return DashboardCursorSyncMultiError(errors)
	}

	return nil
}

// DashboardCursorSyncMultiError is an error wrapping multiple validation
// errors returned by DashboardCursorSync.ValidateAll() if the designated
// constraints aren't met.
type DashboardCursorSyncMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DashboardCursorSyncMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DashboardCursorSyncMultiError) AllErrors() []error { return m }

// DashboardCursorSyncValidationError is the validation error returned by
// DashboardCursorSync.Validate if the designated constraints aren't met.
type DashboardCursorSyncValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DashboardCursorSyncValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DashboardCursorSyncValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DashboardCursorSyncValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DashboardCursorSyncValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DashboardCursorSyncValidationError) ErrorName() string {
	return "DashboardCursorSyncValidationError"
}

// Error satisfies the builtin error interface
func (e DashboardCursorSyncValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDashboardCursorSync.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DashboardCursorSyncValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DashboardCursorSyncValidationError{}

// Validate checks the field values on TimeRange with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeRange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeRangeMultiError, or nil
// if none found.
func (m *TimeRange) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.From != nil {
		// no validation rules for From
	}

	if m.To != nil {
		// no validation rules for To
	}

	if len(errors) > 0 {
		return TimeRangeMultiError(errors)
	}

	return nil
}

// TimeRangeMultiError is an error wrapping multiple validation errors returned
// by TimeRange.ValidateAll() if the designated constraints aren't met.
type TimeRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeRangeMultiError) AllErrors() []error { return m }

// TimeRangeValidationError is the validation error returned by
// TimeRange.Validate if the designated constraints aren't met.
type TimeRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeRangeValidationError) ErrorName() string { return "TimeRangeValidationError" }

// Error satisfies the builtin error interface
func (e TimeRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeRangeValidationError{}

// Validate checks the field values on TimePicker with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimePicker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimePicker with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimePickerMultiError, or
// nil if none found.
func (m *TimePicker) ValidateAll() error {
	return m.validate(true)
}

func (m *TimePicker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRefreshIntervals() {
		_, _ = idx, item

		if !_TimePicker_RefreshIntervals_Pattern.MatchString(item) {
			err := TimePickerValidationError{
				field:  fmt.Sprintf("RefreshIntervals[%v]", idx),
				reason: "value does not match regex pattern \"^[0-9]{0,2}(ms|s|m|h|d|w|M|y)$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetTimeOptions() {
		_, _ = idx, item

		if !_TimePicker_TimeOptions_Pattern.MatchString(item) {
			err := TimePickerValidationError{
				field:  fmt.Sprintf("TimeOptions[%v]", idx),
				reason: "value does not match regex pattern \"^[0-9]{0,2}(ms|s|m|h|d|w|M|y)$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Hidden != nil {
		// no validation rules for Hidden
	}

	if m.Collapse != nil {
		// no validation rules for Collapse
	}

	if m.Enable != nil {
		// no validation rules for Enable
	}

	if len(errors) > 0 {
		return TimePickerMultiError(errors)
	}

	return nil
}

// TimePickerMultiError is an error wrapping multiple validation errors
// returned by TimePicker.ValidateAll() if the designated constraints aren't met.
type TimePickerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimePickerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimePickerMultiError) AllErrors() []error { return m }

// TimePickerValidationError is the validation error returned by
// TimePicker.Validate if the designated constraints aren't met.
type TimePickerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimePickerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimePickerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimePickerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimePickerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimePickerValidationError) ErrorName() string { return "TimePickerValidationError" }

// Error satisfies the builtin error interface
func (e TimePickerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimePicker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimePickerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimePickerValidationError{}

var _TimePicker_RefreshIntervals_Pattern = regexp.MustCompile("^[0-9]{0,2}(ms|s|m|h|d|w|M|y)$")

var _TimePicker_TimeOptions_Pattern = regexp.MustCompile("^[0-9]{0,2}(ms|s|m|h|d|w|M|y)$")

// Validate checks the field values on PanelType with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PanelType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PanelType with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PanelTypeMultiError, or nil
// if none found.
func (m *PanelType) ValidateAll() error {
	return m.validate(true)
}

func (m *PanelType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Selector.(type) {
	case *PanelType_Panel:
		if v == nil {
			err := PanelTypeValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPanel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelTypeValidationError{
						field:  "Panel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelTypeValidationError{
						field:  "Panel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPanel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelTypeValidationError{
					field:  "Panel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PanelType_RowPanel:
		if v == nil {
			err := PanelTypeValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRowPanel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelTypeValidationError{
						field:  "RowPanel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelTypeValidationError{
						field:  "RowPanel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRowPanel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelTypeValidationError{
					field:  "RowPanel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PanelType_GraphPanel:
		if v == nil {
			err := PanelTypeValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGraphPanel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelTypeValidationError{
						field:  "GraphPanel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelTypeValidationError{
						field:  "GraphPanel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGraphPanel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelTypeValidationError{
					field:  "GraphPanel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PanelType_HeatmapPanel:
		if v == nil {
			err := PanelTypeValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHeatmapPanel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelTypeValidationError{
						field:  "HeatmapPanel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelTypeValidationError{
						field:  "HeatmapPanel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHeatmapPanel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelTypeValidationError{
					field:  "HeatmapPanel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PanelTypeMultiError(errors)
	}

	return nil
}

// PanelTypeMultiError is an error wrapping multiple validation errors returned
// by PanelType.ValidateAll() if the designated constraints aren't met.
type PanelTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PanelTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PanelTypeMultiError) AllErrors() []error { return m }

// PanelTypeValidationError is the validation error returned by
// PanelType.Validate if the designated constraints aren't met.
type PanelTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PanelTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PanelTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PanelTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PanelTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PanelTypeValidationError) ErrorName() string { return "PanelTypeValidationError" }

// Error satisfies the builtin error interface
func (e PanelTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPanelType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PanelTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PanelTypeValidationError{}

// Validate checks the field values on Panel with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Panel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Panel with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PanelMultiError, or nil if none found.
func (m *Panel) ValidateAll() error {
	return m.validate(true)
}

func (m *Panel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := PanelValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTargets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  fmt.Sprintf("Targets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  fmt.Sprintf("Targets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelValidationError{
					field:  fmt.Sprintf("Targets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetLinks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  fmt.Sprintf("Links[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  fmt.Sprintf("Links[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelValidationError{
					field:  fmt.Sprintf("Links[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTransformations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  fmt.Sprintf("Transformations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  fmt.Sprintf("Transformations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelValidationError{
					field:  fmt.Sprintf("Transformations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.PluginVersion != nil {
		// no validation rules for PluginVersion
	}

	if m.Title != nil {
		// no validation rules for Title
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Transparent != nil {
		// no validation rules for Transparent
	}

	if m.Datasource != nil {

		if all {
			switch v := interface{}(m.GetDatasource()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  "Datasource",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  "Datasource",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatasource()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelValidationError{
					field:  "Datasource",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GridPos != nil {

		if all {
			switch v := interface{}(m.GetGridPos()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  "GridPos",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  "GridPos",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGridPos()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelValidationError{
					field:  "GridPos",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Repeat != nil {
		// no validation rules for Repeat
	}

	if m.RepeatDirection != nil {

		if _, ok := _Panel_RepeatDirection_InLookup[m.GetRepeatDirection()]; !ok {
			err := PanelValidationError{
				field:  "RepeatDirection",
				reason: "value must be in list [h,v]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.RepeatPanelId != nil {
		// no validation rules for RepeatPanelId
	}

	if m.MaxDataPoints != nil {
		// no validation rules for MaxDataPoints
	}

	if m.Interval != nil {
		// no validation rules for Interval
	}

	if m.TimeFrom != nil {
		// no validation rules for TimeFrom
	}

	if m.TimeShift != nil {
		// no validation rules for TimeShift
	}

	if m.LibraryPanel != nil {

		if all {
			switch v := interface{}(m.GetLibraryPanel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  "LibraryPanel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  "LibraryPanel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLibraryPanel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelValidationError{
					field:  "LibraryPanel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Options != nil {

		if all {
			switch v := interface{}(m.GetOptions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  "Options",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PanelValidationError{
						field:  "Options",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PanelValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.FieldConfig != nil {
		// no validation rules for FieldConfig
	}

	if len(errors) > 0 {
		return PanelMultiError(errors)
	}

	return nil
}

// PanelMultiError is an error wrapping multiple validation errors returned by
// Panel.ValidateAll() if the designated constraints aren't met.
type PanelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PanelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PanelMultiError) AllErrors() []error { return m }

// PanelValidationError is the validation error returned by Panel.Validate if
// the designated constraints aren't met.
type PanelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PanelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PanelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PanelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PanelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PanelValidationError) ErrorName() string { return "PanelValidationError" }

// Error satisfies the builtin error interface
func (e PanelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPanel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PanelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PanelValidationError{}

var _Panel_RepeatDirection_InLookup = map[string]struct{}{
	"h,v": {},
}

// Validate checks the field values on AnnotationTarget with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AnnotationTarget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnnotationTarget with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnnotationTargetMultiError, or nil if none found.
func (m *AnnotationTarget) ValidateAll() error {
	return m.validate(true)
}

func (m *AnnotationTarget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for MatchAny

	// no validation rules for Type

	if len(errors) > 0 {
		return AnnotationTargetMultiError(errors)
	}

	return nil
}

// AnnotationTargetMultiError is an error wrapping multiple validation errors
// returned by AnnotationTarget.ValidateAll() if the designated constraints
// aren't met.
type AnnotationTargetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnnotationTargetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnnotationTargetMultiError) AllErrors() []error { return m }

// AnnotationTargetValidationError is the validation error returned by
// AnnotationTarget.Validate if the designated constraints aren't met.
type AnnotationTargetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnnotationTargetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnnotationTargetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnnotationTargetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnnotationTargetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnnotationTargetValidationError) ErrorName() string { return "AnnotationTargetValidationError" }

// Error satisfies the builtin error interface
func (e AnnotationTargetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotationTarget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnnotationTargetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnnotationTargetValidationError{}

// Validate checks the field values on AnnotationPanelFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AnnotationPanelFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnnotationPanelFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnnotationPanelFilterMultiError, or nil if none found.
func (m *AnnotationPanelFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *AnnotationPanelFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Exclude != nil {
		// no validation rules for Exclude
	}

	if len(errors) > 0 {
		return AnnotationPanelFilterMultiError(errors)
	}

	return nil
}

// AnnotationPanelFilterMultiError is an error wrapping multiple validation
// errors returned by AnnotationPanelFilter.ValidateAll() if the designated
// constraints aren't met.
type AnnotationPanelFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnnotationPanelFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnnotationPanelFilterMultiError) AllErrors() []error { return m }

// AnnotationPanelFilterValidationError is the validation error returned by
// AnnotationPanelFilter.Validate if the designated constraints aren't met.
type AnnotationPanelFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnnotationPanelFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnnotationPanelFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnnotationPanelFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnnotationPanelFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnnotationPanelFilterValidationError) ErrorName() string {
	return "AnnotationPanelFilterValidationError"
}

// Error satisfies the builtin error interface
func (e AnnotationPanelFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotationPanelFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnnotationPanelFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnnotationPanelFilterValidationError{}

// Validate checks the field values on AnnotationContainer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AnnotationContainer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnnotationContainer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnnotationContainerMultiError, or nil if none found.
func (m *AnnotationContainer) ValidateAll() error {
	return m.validate(true)
}

func (m *AnnotationContainer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnnotationContainerValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnnotationContainerValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnnotationContainerValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AnnotationContainerMultiError(errors)
	}

	return nil
}

// AnnotationContainerMultiError is an error wrapping multiple validation
// errors returned by AnnotationContainer.ValidateAll() if the designated
// constraints aren't met.
type AnnotationContainerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnnotationContainerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnnotationContainerMultiError) AllErrors() []error { return m }

// AnnotationContainerValidationError is the validation error returned by
// AnnotationContainer.Validate if the designated constraints aren't met.
type AnnotationContainerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnnotationContainerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnnotationContainerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnnotationContainerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnnotationContainerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnnotationContainerValidationError) ErrorName() string {
	return "AnnotationContainerValidationError"
}

// Error satisfies the builtin error interface
func (e AnnotationContainerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotationContainer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnnotationContainerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnnotationContainerValidationError{}

// Validate checks the field values on VariableModel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VariableModel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VariableModel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VariableModelMultiError, or
// nil if none found.
func (m *VariableModel) ValidateAll() error {
	return m.validate(true)
}

func (m *VariableModel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Hide

	// no validation rules for SkipUrlSync

	for idx, item := range m.GetOptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VariableModelValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VariableModelValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VariableModelValidationError{
					field:  fmt.Sprintf("Options[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Label != nil {
		// no validation rules for Label
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Query != nil {
		// no validation rules for Query
	}

	if m.Datasource != nil {

		if all {
			switch v := interface{}(m.GetDatasource()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VariableModelValidationError{
						field:  "Datasource",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VariableModelValidationError{
						field:  "Datasource",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatasource()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VariableModelValidationError{
					field:  "Datasource",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.AllFormat != nil {
		// no validation rules for AllFormat
	}

	if m.Current != nil {

		if all {
			switch v := interface{}(m.GetCurrent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VariableModelValidationError{
						field:  "Current",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VariableModelValidationError{
						field:  "Current",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCurrent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VariableModelValidationError{
					field:  "Current",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Multi != nil {
		// no validation rules for Multi
	}

	if m.Refresh != nil {
		// no validation rules for Refresh
	}

	if len(errors) > 0 {
		return VariableModelMultiError(errors)
	}

	return nil
}

// VariableModelMultiError is an error wrapping multiple validation errors
// returned by VariableModel.ValidateAll() if the designated constraints
// aren't met.
type VariableModelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VariableModelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VariableModelMultiError) AllErrors() []error { return m }

// VariableModelValidationError is the validation error returned by
// VariableModel.Validate if the designated constraints aren't met.
type VariableModelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VariableModelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VariableModelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VariableModelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VariableModelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VariableModelValidationError) ErrorName() string { return "VariableModelValidationError" }

// Error satisfies the builtin error interface
func (e VariableModelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVariableModel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VariableModelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VariableModelValidationError{}

// Validate checks the field values on DataSourceRef with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataSourceRef) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataSourceRef with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataSourceRefMultiError, or
// nil if none found.
func (m *DataSourceRef) ValidateAll() error {
	return m.validate(true)
}

func (m *DataSourceRef) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Type != nil {
		// no validation rules for Type
	}

	if m.Uid != nil {
		// no validation rules for Uid
	}

	if len(errors) > 0 {
		return DataSourceRefMultiError(errors)
	}

	return nil
}

// DataSourceRefMultiError is an error wrapping multiple validation errors
// returned by DataSourceRef.ValidateAll() if the designated constraints
// aren't met.
type DataSourceRefMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataSourceRefMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataSourceRefMultiError) AllErrors() []error { return m }

// DataSourceRefValidationError is the validation error returned by
// DataSourceRef.Validate if the designated constraints aren't met.
type DataSourceRefValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataSourceRefValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataSourceRefValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataSourceRefValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataSourceRefValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataSourceRefValidationError) ErrorName() string { return "DataSourceRefValidationError" }

// Error satisfies the builtin error interface
func (e DataSourceRefValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataSourceRef.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataSourceRefValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataSourceRefValidationError{}

// Validate checks the field values on DashboardLink with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DashboardLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DashboardLink with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DashboardLinkMultiError, or
// nil if none found.
func (m *DashboardLink) ValidateAll() error {
	return m.validate(true)
}

func (m *DashboardLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Type

	// no validation rules for Icon

	// no validation rules for Tooltip

	// no validation rules for Url

	// no validation rules for AsDropdown

	// no validation rules for TargetBlank

	// no validation rules for IncludeVars

	// no validation rules for KeepTime

	if len(errors) > 0 {
		return DashboardLinkMultiError(errors)
	}

	return nil
}

// DashboardLinkMultiError is an error wrapping multiple validation errors
// returned by DashboardLink.ValidateAll() if the designated constraints
// aren't met.
type DashboardLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DashboardLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DashboardLinkMultiError) AllErrors() []error { return m }

// DashboardLinkValidationError is the validation error returned by
// DashboardLink.Validate if the designated constraints aren't met.
type DashboardLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DashboardLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DashboardLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DashboardLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DashboardLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DashboardLinkValidationError) ErrorName() string { return "DashboardLinkValidationError" }

// Error satisfies the builtin error interface
func (e DashboardLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDashboardLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DashboardLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DashboardLinkValidationError{}

// Validate checks the field values on FieldColor with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FieldColor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FieldColor with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FieldColorMultiError, or
// nil if none found.
func (m *FieldColor) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldColor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mode

	if m.FixedColor != nil {
		// no validation rules for FixedColor
	}

	if m.SeriesBy != nil {
		// no validation rules for SeriesBy
	}

	if len(errors) > 0 {
		return FieldColorMultiError(errors)
	}

	return nil
}

// FieldColorMultiError is an error wrapping multiple validation errors
// returned by FieldColor.ValidateAll() if the designated constraints aren't met.
type FieldColorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldColorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldColorMultiError) AllErrors() []error { return m }

// FieldColorValidationError is the validation error returned by
// FieldColor.Validate if the designated constraints aren't met.
type FieldColorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldColorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldColorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldColorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldColorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldColorValidationError) ErrorName() string { return "FieldColorValidationError" }

// Error satisfies the builtin error interface
func (e FieldColorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldColor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldColorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldColorValidationError{}

// Validate checks the field values on GridPos with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GridPos) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GridPos with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GridPosMultiError, or nil if none found.
func (m *GridPos) ValidateAll() error {
	return m.validate(true)
}

func (m *GridPos) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetH() <= 0 {
		err := GridPosValidationError{
			field:  "H",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetW(); val <= 0 || val > 24 {
		err := GridPosValidationError{
			field:  "W",
			reason: "value must be inside range (0, 24]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetX(); val < 0 || val >= 24 {
		err := GridPosValidationError{
			field:  "X",
			reason: "value must be inside range [0, 24)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Y

	if m.Static != nil {
		// no validation rules for Static
	}

	if len(errors) > 0 {
		return GridPosMultiError(errors)
	}

	return nil
}

// GridPosMultiError is an error wrapping multiple validation errors returned
// by GridPos.ValidateAll() if the designated constraints aren't met.
type GridPosMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GridPosMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GridPosMultiError) AllErrors() []error { return m }

// GridPosValidationError is the validation error returned by GridPos.Validate
// if the designated constraints aren't met.
type GridPosValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GridPosValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GridPosValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GridPosValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GridPosValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GridPosValidationError) ErrorName() string { return "GridPosValidationError" }

// Error satisfies the builtin error interface
func (e GridPosValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGridPos.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GridPosValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GridPosValidationError{}

// Validate checks the field values on Threshold with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Threshold) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Threshold with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ThresholdMultiError, or nil
// if none found.
func (m *Threshold) ValidateAll() error {
	return m.validate(true)
}

func (m *Threshold) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Color

	if len(errors) > 0 {
		return ThresholdMultiError(errors)
	}

	return nil
}

// ThresholdMultiError is an error wrapping multiple validation errors returned
// by Threshold.ValidateAll() if the designated constraints aren't met.
type ThresholdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ThresholdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ThresholdMultiError) AllErrors() []error { return m }

// ThresholdValidationError is the validation error returned by
// Threshold.Validate if the designated constraints aren't met.
type ThresholdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ThresholdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ThresholdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ThresholdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ThresholdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ThresholdValidationError) ErrorName() string { return "ThresholdValidationError" }

// Error satisfies the builtin error interface
func (e ThresholdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sThreshold.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ThresholdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ThresholdValidationError{}

// Validate checks the field values on ThresholdsConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ThresholdsConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ThresholdsConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ThresholdsConfigMultiError, or nil if none found.
func (m *ThresholdsConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ThresholdsConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mode

	for idx, item := range m.GetSteps() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ThresholdsConfigValidationError{
						field:  fmt.Sprintf("Steps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ThresholdsConfigValidationError{
						field:  fmt.Sprintf("Steps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ThresholdsConfigValidationError{
					field:  fmt.Sprintf("Steps[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ThresholdsConfigMultiError(errors)
	}

	return nil
}

// ThresholdsConfigMultiError is an error wrapping multiple validation errors
// returned by ThresholdsConfig.ValidateAll() if the designated constraints
// aren't met.
type ThresholdsConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ThresholdsConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ThresholdsConfigMultiError) AllErrors() []error { return m }

// ThresholdsConfigValidationError is the validation error returned by
// ThresholdsConfig.Validate if the designated constraints aren't met.
type ThresholdsConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ThresholdsConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ThresholdsConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ThresholdsConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ThresholdsConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ThresholdsConfigValidationError) ErrorName() string { return "ThresholdsConfigValidationError" }

// Error satisfies the builtin error interface
func (e ThresholdsConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sThresholdsConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ThresholdsConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ThresholdsConfigValidationError{}

// Validate checks the field values on ValueMapping with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ValueMapping) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValueMapping with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ValueMappingMultiError, or
// nil if none found.
func (m *ValueMapping) ValidateAll() error {
	return m.validate(true)
}

func (m *ValueMapping) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Selector.(type) {
	case *ValueMapping_ValueMap:
		if v == nil {
			err := ValueMappingValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetValueMap()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueMappingValidationError{
						field:  "ValueMap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueMappingValidationError{
						field:  "ValueMap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetValueMap()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueMappingValidationError{
					field:  "ValueMap",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ValueMapping_RangeMap:
		if v == nil {
			err := ValueMappingValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRangeMap()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueMappingValidationError{
						field:  "RangeMap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueMappingValidationError{
						field:  "RangeMap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRangeMap()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueMappingValidationError{
					field:  "RangeMap",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ValueMapping_RegexMap:
		if v == nil {
			err := ValueMappingValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRegexMap()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueMappingValidationError{
						field:  "RegexMap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueMappingValidationError{
						field:  "RegexMap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRegexMap()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueMappingValidationError{
					field:  "RegexMap",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ValueMapping_SpecialValueMap:
		if v == nil {
			err := ValueMappingValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSpecialValueMap()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueMappingValidationError{
						field:  "SpecialValueMap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueMappingValidationError{
						field:  "SpecialValueMap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSpecialValueMap()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueMappingValidationError{
					field:  "SpecialValueMap",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ValueMappingMultiError(errors)
	}

	return nil
}

// ValueMappingMultiError is an error wrapping multiple validation errors
// returned by ValueMapping.ValidateAll() if the designated constraints aren't met.
type ValueMappingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValueMappingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValueMappingMultiError) AllErrors() []error { return m }

// ValueMappingValidationError is the validation error returned by
// ValueMapping.Validate if the designated constraints aren't met.
type ValueMappingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValueMappingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValueMappingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValueMappingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValueMappingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValueMappingValidationError) ErrorName() string { return "ValueMappingValidationError" }

// Error satisfies the builtin error interface
func (e ValueMappingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValueMapping.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValueMappingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValueMappingValidationError{}

// Validate checks the field values on ValueMap with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ValueMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValueMap with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ValueMapMultiError, or nil
// if none found.
func (m *ValueMap) ValidateAll() error {
	return m.validate(true)
}

func (m *ValueMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	{
		sorted_keys := make([]string, len(m.GetOptions()))
		i := 0
		for key := range m.GetOptions() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetOptions()[key]
			_ = val

			// no validation rules for Options[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ValueMapValidationError{
							field:  fmt.Sprintf("Options[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ValueMapValidationError{
							field:  fmt.Sprintf("Options[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ValueMapValidationError{
						field:  fmt.Sprintf("Options[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ValueMapMultiError(errors)
	}

	return nil
}

// ValueMapMultiError is an error wrapping multiple validation errors returned
// by ValueMap.ValidateAll() if the designated constraints aren't met.
type ValueMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValueMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValueMapMultiError) AllErrors() []error { return m }

// ValueMapValidationError is the validation error returned by
// ValueMap.Validate if the designated constraints aren't met.
type ValueMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValueMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValueMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValueMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValueMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValueMapValidationError) ErrorName() string { return "ValueMapValidationError" }

// Error satisfies the builtin error interface
func (e ValueMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValueMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValueMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValueMapValidationError{}

// Validate checks the field values on RangeMap with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RangeMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RangeMap with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RangeMapMultiError, or nil
// if none found.
func (m *RangeMap) ValidateAll() error {
	return m.validate(true)
}

func (m *RangeMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeMapValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeMapValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeMapValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RangeMapMultiError(errors)
	}

	return nil
}

// RangeMapMultiError is an error wrapping multiple validation errors returned
// by RangeMap.ValidateAll() if the designated constraints aren't met.
type RangeMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeMapMultiError) AllErrors() []error { return m }

// RangeMapValidationError is the validation error returned by
// RangeMap.Validate if the designated constraints aren't met.
type RangeMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeMapValidationError) ErrorName() string { return "RangeMapValidationError" }

// Error satisfies the builtin error interface
func (e RangeMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeMapValidationError{}

// Validate checks the field values on RegexMap with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegexMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegexMap with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegexMapMultiError, or nil
// if none found.
func (m *RegexMap) ValidateAll() error {
	return m.validate(true)
}

func (m *RegexMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegexMapValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegexMapValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegexMapValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegexMapMultiError(errors)
	}

	return nil
}

// RegexMapMultiError is an error wrapping multiple validation errors returned
// by RegexMap.ValidateAll() if the designated constraints aren't met.
type RegexMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegexMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegexMapMultiError) AllErrors() []error { return m }

// RegexMapValidationError is the validation error returned by
// RegexMap.Validate if the designated constraints aren't met.
type RegexMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegexMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegexMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegexMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegexMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegexMapValidationError) ErrorName() string { return "RegexMapValidationError" }

// Error satisfies the builtin error interface
func (e RegexMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegexMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegexMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegexMapValidationError{}

// Validate checks the field values on SpecialValueMap with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SpecialValueMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpecialValueMap with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpecialValueMapMultiError, or nil if none found.
func (m *SpecialValueMap) ValidateAll() error {
	return m.validate(true)
}

func (m *SpecialValueMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecialValueMapValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecialValueMapValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecialValueMapValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SpecialValueMapMultiError(errors)
	}

	return nil
}

// SpecialValueMapMultiError is an error wrapping multiple validation errors
// returned by SpecialValueMap.ValidateAll() if the designated constraints
// aren't met.
type SpecialValueMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpecialValueMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpecialValueMapMultiError) AllErrors() []error { return m }

// SpecialValueMapValidationError is the validation error returned by
// SpecialValueMap.Validate if the designated constraints aren't met.
type SpecialValueMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpecialValueMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpecialValueMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpecialValueMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpecialValueMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpecialValueMapValidationError) ErrorName() string { return "SpecialValueMapValidationError" }

// Error satisfies the builtin error interface
func (e SpecialValueMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecialValueMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpecialValueMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpecialValueMapValidationError{}

// Validate checks the field values on ValueMappingResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ValueMappingResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValueMappingResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValueMappingResultMultiError, or nil if none found.
func (m *ValueMappingResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ValueMappingResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Text != nil {
		// no validation rules for Text
	}

	if m.Color != nil {
		// no validation rules for Color
	}

	if m.Icon != nil {
		// no validation rules for Icon
	}

	if m.Index != nil {
		// no validation rules for Index
	}

	if len(errors) > 0 {
		return ValueMappingResultMultiError(errors)
	}

	return nil
}

// ValueMappingResultMultiError is an error wrapping multiple validation errors
// returned by ValueMappingResult.ValidateAll() if the designated constraints
// aren't met.
type ValueMappingResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValueMappingResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValueMappingResultMultiError) AllErrors() []error { return m }

// ValueMappingResultValidationError is the validation error returned by
// ValueMappingResult.Validate if the designated constraints aren't met.
type ValueMappingResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValueMappingResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValueMappingResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValueMappingResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValueMappingResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValueMappingResultValidationError) ErrorName() string {
	return "ValueMappingResultValidationError"
}

// Error satisfies the builtin error interface
func (e ValueMappingResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValueMappingResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValueMappingResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValueMappingResultValidationError{}

// Validate checks the field values on DataTransformerConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DataTransformerConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataTransformerConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DataTransformerConfigMultiError, or nil if none found.
func (m *DataTransformerConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *DataTransformerConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataTransformerConfigValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataTransformerConfigValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataTransformerConfigValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Disabled != nil {
		// no validation rules for Disabled
	}

	if m.Filter != nil {

		if all {
			switch v := interface{}(m.GetFilter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DataTransformerConfigValidationError{
						field:  "Filter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DataTransformerConfigValidationError{
						field:  "Filter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DataTransformerConfigValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DataTransformerConfigMultiError(errors)
	}

	return nil
}

// DataTransformerConfigMultiError is an error wrapping multiple validation
// errors returned by DataTransformerConfig.ValidateAll() if the designated
// constraints aren't met.
type DataTransformerConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataTransformerConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataTransformerConfigMultiError) AllErrors() []error { return m }

// DataTransformerConfigValidationError is the validation error returned by
// DataTransformerConfig.Validate if the designated constraints aren't met.
type DataTransformerConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataTransformerConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataTransformerConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataTransformerConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataTransformerConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataTransformerConfigValidationError) ErrorName() string {
	return "DataTransformerConfigValidationError"
}

// Error satisfies the builtin error interface
func (e DataTransformerConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataTransformerConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataTransformerConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataTransformerConfigValidationError{}

// Validate checks the field values on Target with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Target) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Target with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TargetMultiError, or nil if none found.
func (m *Target) ValidateAll() error {
	return m.validate(true)
}

func (m *Target) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExpr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TargetValidationError{
					field:  "Expr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TargetValidationError{
					field:  "Expr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TargetValidationError{
				field:  "Expr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TargetMultiError(errors)
	}

	return nil
}

// TargetMultiError is an error wrapping multiple validation errors returned by
// Target.ValidateAll() if the designated constraints aren't met.
type TargetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TargetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TargetMultiError) AllErrors() []error { return m }

// TargetValidationError is the validation error returned by Target.Validate if
// the designated constraints aren't met.
type TargetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TargetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TargetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TargetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TargetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TargetValidationError) ErrorName() string { return "TargetValidationError" }

// Error satisfies the builtin error interface
func (e TargetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTarget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TargetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TargetValidationError{}

// Validate checks the field values on Snapshot with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Snapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Snapshot with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SnapshotMultiError, or nil
// if none found.
func (m *Snapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *Snapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Created

	// no validation rules for Expires

	// no validation rules for External

	// no validation rules for ExternalUrl

	// no validation rules for Id

	// no validation rules for Key

	// no validation rules for Name

	// no validation rules for OrgId

	// no validation rules for Updated

	// no validation rules for UserId

	if m.Url != nil {
		// no validation rules for Url
	}

	if len(errors) > 0 {
		return SnapshotMultiError(errors)
	}

	return nil
}

// SnapshotMultiError is an error wrapping multiple validation errors returned
// by Snapshot.ValidateAll() if the designated constraints aren't met.
type SnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnapshotMultiError) AllErrors() []error { return m }

// SnapshotValidationError is the validation error returned by
// Snapshot.Validate if the designated constraints aren't met.
type SnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnapshotValidationError) ErrorName() string { return "SnapshotValidationError" }

// Error satisfies the builtin error interface
func (e SnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnapshotValidationError{}

// Validate checks the field values on FieldConfigSource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FieldConfigSource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FieldConfigSource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FieldConfigSourceMultiError, or nil if none found.
func (m *FieldConfigSource) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldConfigSource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDefaults()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FieldConfigSourceValidationError{
					field:  "Defaults",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FieldConfigSourceValidationError{
					field:  "Defaults",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaults()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FieldConfigSourceValidationError{
				field:  "Defaults",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOverrides() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldConfigSourceValidationError{
						field:  fmt.Sprintf("Overrides[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldConfigSourceValidationError{
						field:  fmt.Sprintf("Overrides[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldConfigSourceValidationError{
					field:  fmt.Sprintf("Overrides[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FieldConfigSourceMultiError(errors)
	}

	return nil
}

// FieldConfigSourceMultiError is an error wrapping multiple validation errors
// returned by FieldConfigSource.ValidateAll() if the designated constraints
// aren't met.
type FieldConfigSourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldConfigSourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldConfigSourceMultiError) AllErrors() []error { return m }

// FieldConfigSourceValidationError is the validation error returned by
// FieldConfigSource.Validate if the designated constraints aren't met.
type FieldConfigSourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldConfigSourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldConfigSourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldConfigSourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldConfigSourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldConfigSourceValidationError) ErrorName() string {
	return "FieldConfigSourceValidationError"
}

// Error satisfies the builtin error interface
func (e FieldConfigSourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldConfigSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldConfigSourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldConfigSourceValidationError{}

// Validate checks the field values on LibraryPanelRef with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LibraryPanelRef) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LibraryPanelRef with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LibraryPanelRefMultiError, or nil if none found.
func (m *LibraryPanelRef) ValidateAll() error {
	return m.validate(true)
}

func (m *LibraryPanelRef) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Uid

	if len(errors) > 0 {
		return LibraryPanelRefMultiError(errors)
	}

	return nil
}

// LibraryPanelRefMultiError is an error wrapping multiple validation errors
// returned by LibraryPanelRef.ValidateAll() if the designated constraints
// aren't met.
type LibraryPanelRefMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LibraryPanelRefMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LibraryPanelRefMultiError) AllErrors() []error { return m }

// LibraryPanelRefValidationError is the validation error returned by
// LibraryPanelRef.Validate if the designated constraints aren't met.
type LibraryPanelRefValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LibraryPanelRefValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LibraryPanelRefValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LibraryPanelRefValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LibraryPanelRefValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LibraryPanelRefValidationError) ErrorName() string { return "LibraryPanelRefValidationError" }

// Error satisfies the builtin error interface
func (e LibraryPanelRefValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLibraryPanelRef.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LibraryPanelRefValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LibraryPanelRefValidationError{}

// Validate checks the field values on MatcherConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MatcherConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatcherConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MatcherConfigMultiError, or
// nil if none found.
func (m *MatcherConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MatcherConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetOptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MatcherConfigValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MatcherConfigValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatcherConfigValidationError{
					field:  fmt.Sprintf("Options[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MatcherConfigMultiError(errors)
	}

	return nil
}

// MatcherConfigMultiError is an error wrapping multiple validation errors
// returned by MatcherConfig.ValidateAll() if the designated constraints
// aren't met.
type MatcherConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatcherConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatcherConfigMultiError) AllErrors() []error { return m }

// MatcherConfigValidationError is the validation error returned by
// MatcherConfig.Validate if the designated constraints aren't met.
type MatcherConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatcherConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatcherConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatcherConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatcherConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatcherConfigValidationError) ErrorName() string { return "MatcherConfigValidationError" }

// Error satisfies the builtin error interface
func (e MatcherConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatcherConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatcherConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatcherConfigValidationError{}

// Validate checks the field values on DynamicConfigValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DynamicConfigValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DynamicConfigValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DynamicConfigValueMultiError, or nil if none found.
func (m *DynamicConfigValue) ValidateAll() error {
	return m.validate(true)
}

func (m *DynamicConfigValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.Value != nil {

		if all {
			switch v := interface{}(m.GetValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DynamicConfigValueValidationError{
						field:  "Value",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DynamicConfigValueValidationError{
						field:  "Value",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DynamicConfigValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DynamicConfigValueMultiError(errors)
	}

	return nil
}

// DynamicConfigValueMultiError is an error wrapping multiple validation errors
// returned by DynamicConfigValue.ValidateAll() if the designated constraints
// aren't met.
type DynamicConfigValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DynamicConfigValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DynamicConfigValueMultiError) AllErrors() []error { return m }

// DynamicConfigValueValidationError is the validation error returned by
// DynamicConfigValue.Validate if the designated constraints aren't met.
type DynamicConfigValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DynamicConfigValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DynamicConfigValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DynamicConfigValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DynamicConfigValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DynamicConfigValueValidationError) ErrorName() string {
	return "DynamicConfigValueValidationError"
}

// Error satisfies the builtin error interface
func (e DynamicConfigValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDynamicConfigValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DynamicConfigValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DynamicConfigValueValidationError{}

// Validate checks the field values on FieldConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FieldConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FieldConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FieldConfigMultiError, or
// nil if none found.
func (m *FieldConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMappings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldConfigValidationError{
						field:  fmt.Sprintf("Mappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldConfigValidationError{
						field:  fmt.Sprintf("Mappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldConfigValidationError{
					field:  fmt.Sprintf("Mappings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetLinks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldConfigValidationError{
						field:  fmt.Sprintf("Links[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldConfigValidationError{
						field:  fmt.Sprintf("Links[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldConfigValidationError{
					field:  fmt.Sprintf("Links[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DisplayName != nil {
		// no validation rules for DisplayName
	}

	if m.DisplayNameFromDS != nil {
		// no validation rules for DisplayNameFromDS
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Path != nil {
		// no validation rules for Path
	}

	if m.Writable != nil {
		// no validation rules for Writable
	}

	if m.Filterable != nil {
		// no validation rules for Filterable
	}

	if m.Unit != nil {
		// no validation rules for Unit
	}

	if m.Decimals != nil {
		// no validation rules for Decimals
	}

	if m.Min != nil {
		// no validation rules for Min
	}

	if m.Max != nil {
		// no validation rules for Max
	}

	if m.Thresholds != nil {

		if all {
			switch v := interface{}(m.GetThresholds()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldConfigValidationError{
						field:  "Thresholds",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldConfigValidationError{
						field:  "Thresholds",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetThresholds()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldConfigValidationError{
					field:  "Thresholds",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Color != nil {

		if all {
			switch v := interface{}(m.GetColor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldConfigValidationError{
						field:  "Color",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldConfigValidationError{
						field:  "Color",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldConfigValidationError{
					field:  "Color",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NoValue != nil {
		// no validation rules for NoValue
	}

	if m.Custom != nil {

		if all {
			switch v := interface{}(m.GetCustom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldConfigValidationError{
						field:  "Custom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldConfigValidationError{
						field:  "Custom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCustom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldConfigValidationError{
					field:  "Custom",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FieldConfigMultiError(errors)
	}

	return nil
}

// FieldConfigMultiError is an error wrapping multiple validation errors
// returned by FieldConfig.ValidateAll() if the designated constraints aren't met.
type FieldConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldConfigMultiError) AllErrors() []error { return m }

// FieldConfigValidationError is the validation error returned by
// FieldConfig.Validate if the designated constraints aren't met.
type FieldConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldConfigValidationError) ErrorName() string { return "FieldConfigValidationError" }

// Error satisfies the builtin error interface
func (e FieldConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldConfigValidationError{}

// Validate checks the field values on RowPanel with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RowPanel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RowPanel with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RowPanelMultiError, or nil
// if none found.
func (m *RowPanel) ValidateAll() error {
	return m.validate(true)
}

func (m *RowPanel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Collapsed

	// no validation rules for Id

	for idx, item := range m.GetPanels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RowPanelValidationError{
						field:  fmt.Sprintf("Panels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RowPanelValidationError{
						field:  fmt.Sprintf("Panels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RowPanelValidationError{
					field:  fmt.Sprintf("Panels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Title != nil {
		// no validation rules for Title
	}

	if m.Datasource != nil {

		if all {
			switch v := interface{}(m.GetDatasource()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RowPanelValidationError{
						field:  "Datasource",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RowPanelValidationError{
						field:  "Datasource",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatasource()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RowPanelValidationError{
					field:  "Datasource",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GridPos != nil {

		if all {
			switch v := interface{}(m.GetGridPos()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RowPanelValidationError{
						field:  "GridPos",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RowPanelValidationError{
						field:  "GridPos",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGridPos()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RowPanelValidationError{
					field:  "GridPos",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Repeat != nil {
		// no validation rules for Repeat
	}

	if len(errors) > 0 {
		return RowPanelMultiError(errors)
	}

	return nil
}

// RowPanelMultiError is an error wrapping multiple validation errors returned
// by RowPanel.ValidateAll() if the designated constraints aren't met.
type RowPanelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RowPanelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RowPanelMultiError) AllErrors() []error { return m }

// RowPanelValidationError is the validation error returned by
// RowPanel.Validate if the designated constraints aren't met.
type RowPanelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RowPanelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RowPanelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RowPanelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RowPanelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RowPanelValidationError) ErrorName() string { return "RowPanelValidationError" }

// Error satisfies the builtin error interface
func (e RowPanelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRowPanel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RowPanelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RowPanelValidationError{}

// Validate checks the field values on GraphPanel with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GraphPanel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GraphPanel with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GraphPanelMultiError, or
// nil if none found.
func (m *GraphPanel) ValidateAll() error {
	return m.validate(true)
}

func (m *GraphPanel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if m.Legend != nil {

		if all {
			switch v := interface{}(m.GetLegend()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GraphPanelValidationError{
						field:  "Legend",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GraphPanelValidationError{
						field:  "Legend",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLegend()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GraphPanelValidationError{
					field:  "Legend",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GraphPanelMultiError(errors)
	}

	return nil
}

// GraphPanelMultiError is an error wrapping multiple validation errors
// returned by GraphPanel.ValidateAll() if the designated constraints aren't met.
type GraphPanelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GraphPanelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GraphPanelMultiError) AllErrors() []error { return m }

// GraphPanelValidationError is the validation error returned by
// GraphPanel.Validate if the designated constraints aren't met.
type GraphPanelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GraphPanelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GraphPanelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GraphPanelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GraphPanelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GraphPanelValidationError) ErrorName() string { return "GraphPanelValidationError" }

// Error satisfies the builtin error interface
func (e GraphPanelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGraphPanel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GraphPanelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GraphPanelValidationError{}

// Validate checks the field values on HeatmapPanel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HeatmapPanel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeatmapPanel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HeatmapPanelMultiError, or
// nil if none found.
func (m *HeatmapPanel) ValidateAll() error {
	return m.validate(true)
}

func (m *HeatmapPanel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if len(errors) > 0 {
		return HeatmapPanelMultiError(errors)
	}

	return nil
}

// HeatmapPanelMultiError is an error wrapping multiple validation errors
// returned by HeatmapPanel.ValidateAll() if the designated constraints aren't met.
type HeatmapPanelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeatmapPanelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeatmapPanelMultiError) AllErrors() []error { return m }

// HeatmapPanelValidationError is the validation error returned by
// HeatmapPanel.Validate if the designated constraints aren't met.
type HeatmapPanelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeatmapPanelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeatmapPanelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeatmapPanelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeatmapPanelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeatmapPanelValidationError) ErrorName() string { return "HeatmapPanelValidationError" }

// Error satisfies the builtin error interface
func (e HeatmapPanelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeatmapPanel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeatmapPanelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeatmapPanelValidationError{}

// Validate checks the field values on Dashboard_Templating with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Dashboard_Templating) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Dashboard_Templating with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Dashboard_TemplatingMultiError, or nil if none found.
func (m *Dashboard_Templating) ValidateAll() error {
	return m.validate(true)
}

func (m *Dashboard_Templating) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Dashboard_TemplatingValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Dashboard_TemplatingValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Dashboard_TemplatingValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Dashboard_TemplatingMultiError(errors)
	}

	return nil
}

// Dashboard_TemplatingMultiError is an error wrapping multiple validation
// errors returned by Dashboard_Templating.ValidateAll() if the designated
// constraints aren't met.
type Dashboard_TemplatingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Dashboard_TemplatingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Dashboard_TemplatingMultiError) AllErrors() []error { return m }

// Dashboard_TemplatingValidationError is the validation error returned by
// Dashboard_Templating.Validate if the designated constraints aren't met.
type Dashboard_TemplatingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Dashboard_TemplatingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Dashboard_TemplatingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Dashboard_TemplatingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Dashboard_TemplatingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Dashboard_TemplatingValidationError) ErrorName() string {
	return "Dashboard_TemplatingValidationError"
}

// Error satisfies the builtin error interface
func (e Dashboard_TemplatingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDashboard_Templating.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Dashboard_TemplatingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Dashboard_TemplatingValidationError{}

// Validate checks the field values on AnnotationContainer_AnnotationQuery with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *AnnotationContainer_AnnotationQuery) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnnotationContainer_AnnotationQuery
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// AnnotationContainer_AnnotationQueryMultiError, or nil if none found.
func (m *AnnotationContainer_AnnotationQuery) ValidateAll() error {
	return m.validate(true)
}

func (m *AnnotationContainer_AnnotationQuery) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetDatasource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnnotationContainer_AnnotationQueryValidationError{
					field:  "Datasource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnnotationContainer_AnnotationQueryValidationError{
					field:  "Datasource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatasource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnnotationContainer_AnnotationQueryValidationError{
				field:  "Datasource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Enable

	// no validation rules for IconColor

	// no validation rules for DatasourceStr

	if m.Hide != nil {
		// no validation rules for Hide
	}

	if m.Filter != nil {

		if all {
			switch v := interface{}(m.GetFilter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnnotationContainer_AnnotationQueryValidationError{
						field:  "Filter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnnotationContainer_AnnotationQueryValidationError{
						field:  "Filter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnnotationContainer_AnnotationQueryValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Target != nil {

		if all {
			switch v := interface{}(m.GetTarget()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnnotationContainer_AnnotationQueryValidationError{
						field:  "Target",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnnotationContainer_AnnotationQueryValidationError{
						field:  "Target",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnnotationContainer_AnnotationQueryValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Type != nil {
		// no validation rules for Type
	}

	if len(errors) > 0 {
		return AnnotationContainer_AnnotationQueryMultiError(errors)
	}

	return nil
}

// AnnotationContainer_AnnotationQueryMultiError is an error wrapping multiple
// validation errors returned by
// AnnotationContainer_AnnotationQuery.ValidateAll() if the designated
// constraints aren't met.
type AnnotationContainer_AnnotationQueryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnnotationContainer_AnnotationQueryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnnotationContainer_AnnotationQueryMultiError) AllErrors() []error { return m }

// AnnotationContainer_AnnotationQueryValidationError is the validation error
// returned by AnnotationContainer_AnnotationQuery.Validate if the designated
// constraints aren't met.
type AnnotationContainer_AnnotationQueryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnnotationContainer_AnnotationQueryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnnotationContainer_AnnotationQueryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnnotationContainer_AnnotationQueryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnnotationContainer_AnnotationQueryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnnotationContainer_AnnotationQueryValidationError) ErrorName() string {
	return "AnnotationContainer_AnnotationQueryValidationError"
}

// Error satisfies the builtin error interface
func (e AnnotationContainer_AnnotationQueryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotationContainer_AnnotationQuery.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnnotationContainer_AnnotationQueryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnnotationContainer_AnnotationQueryValidationError{}

// Validate checks the field values on VariableModel_VariableOption with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VariableModel_VariableOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VariableModel_VariableOption with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VariableModel_VariableOptionMultiError, or nil if none found.
func (m *VariableModel_VariableOption) ValidateAll() error {
	return m.validate(true)
}

func (m *VariableModel_VariableOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Text

	// no validation rules for Value

	if m.Selected != nil {
		// no validation rules for Selected
	}

	if len(errors) > 0 {
		return VariableModel_VariableOptionMultiError(errors)
	}

	return nil
}

// VariableModel_VariableOptionMultiError is an error wrapping multiple
// validation errors returned by VariableModel_VariableOption.ValidateAll() if
// the designated constraints aren't met.
type VariableModel_VariableOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VariableModel_VariableOptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VariableModel_VariableOptionMultiError) AllErrors() []error { return m }

// VariableModel_VariableOptionValidationError is the validation error returned
// by VariableModel_VariableOption.Validate if the designated constraints
// aren't met.
type VariableModel_VariableOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VariableModel_VariableOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VariableModel_VariableOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VariableModel_VariableOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VariableModel_VariableOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VariableModel_VariableOptionValidationError) ErrorName() string {
	return "VariableModel_VariableOptionValidationError"
}

// Error satisfies the builtin error interface
func (e VariableModel_VariableOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVariableModel_VariableOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VariableModel_VariableOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VariableModel_VariableOptionValidationError{}

// Validate checks the field values on RangeMap_Options with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RangeMap_Options) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RangeMap_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RangeMap_OptionsMultiError, or nil if none found.
func (m *RangeMap_Options) ValidateAll() error {
	return m.validate(true)
}

func (m *RangeMap_Options) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for To

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RangeMap_OptionsValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RangeMap_OptionsValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RangeMap_OptionsValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RangeMap_OptionsMultiError(errors)
	}

	return nil
}

// RangeMap_OptionsMultiError is an error wrapping multiple validation errors
// returned by RangeMap_Options.ValidateAll() if the designated constraints
// aren't met.
type RangeMap_OptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeMap_OptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeMap_OptionsMultiError) AllErrors() []error { return m }

// RangeMap_OptionsValidationError is the validation error returned by
// RangeMap_Options.Validate if the designated constraints aren't met.
type RangeMap_OptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeMap_OptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeMap_OptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeMap_OptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeMap_OptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeMap_OptionsValidationError) ErrorName() string { return "RangeMap_OptionsValidationError" }

// Error satisfies the builtin error interface
func (e RangeMap_OptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRangeMap_Options.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeMap_OptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeMap_OptionsValidationError{}

// Validate checks the field values on RegexMap_Options with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegexMap_Options) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegexMap_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegexMap_OptionsMultiError, or nil if none found.
func (m *RegexMap_Options) ValidateAll() error {
	return m.validate(true)
}

func (m *RegexMap_Options) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pattern

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegexMap_OptionsValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegexMap_OptionsValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegexMap_OptionsValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegexMap_OptionsMultiError(errors)
	}

	return nil
}

// RegexMap_OptionsMultiError is an error wrapping multiple validation errors
// returned by RegexMap_Options.ValidateAll() if the designated constraints
// aren't met.
type RegexMap_OptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegexMap_OptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegexMap_OptionsMultiError) AllErrors() []error { return m }

// RegexMap_OptionsValidationError is the validation error returned by
// RegexMap_Options.Validate if the designated constraints aren't met.
type RegexMap_OptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegexMap_OptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegexMap_OptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegexMap_OptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegexMap_OptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegexMap_OptionsValidationError) ErrorName() string { return "RegexMap_OptionsValidationError" }

// Error satisfies the builtin error interface
func (e RegexMap_OptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegexMap_Options.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegexMap_OptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegexMap_OptionsValidationError{}

// Validate checks the field values on SpecialValueMap_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SpecialValueMap_Options) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpecialValueMap_Options with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpecialValueMap_OptionsMultiError, or nil if none found.
func (m *SpecialValueMap_Options) ValidateAll() error {
	return m.validate(true)
}

func (m *SpecialValueMap_Options) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Match

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpecialValueMap_OptionsValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpecialValueMap_OptionsValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpecialValueMap_OptionsValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SpecialValueMap_OptionsMultiError(errors)
	}

	return nil
}

// SpecialValueMap_OptionsMultiError is an error wrapping multiple validation
// errors returned by SpecialValueMap_Options.ValidateAll() if the designated
// constraints aren't met.
type SpecialValueMap_OptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpecialValueMap_OptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpecialValueMap_OptionsMultiError) AllErrors() []error { return m }

// SpecialValueMap_OptionsValidationError is the validation error returned by
// SpecialValueMap_Options.Validate if the designated constraints aren't met.
type SpecialValueMap_OptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpecialValueMap_OptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpecialValueMap_OptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpecialValueMap_OptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpecialValueMap_OptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpecialValueMap_OptionsValidationError) ErrorName() string {
	return "SpecialValueMap_OptionsValidationError"
}

// Error satisfies the builtin error interface
func (e SpecialValueMap_OptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecialValueMap_Options.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpecialValueMap_OptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpecialValueMap_OptionsValidationError{}

// Validate checks the field values on FieldConfigSource_FieldConfigOverrides
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *FieldConfigSource_FieldConfigOverrides) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// FieldConfigSource_FieldConfigOverrides with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// FieldConfigSource_FieldConfigOverridesMultiError, or nil if none found.
func (m *FieldConfigSource_FieldConfigOverrides) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldConfigSource_FieldConfigOverrides) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMatcher()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FieldConfigSource_FieldConfigOverridesValidationError{
					field:  "Matcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FieldConfigSource_FieldConfigOverridesValidationError{
					field:  "Matcher",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMatcher()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FieldConfigSource_FieldConfigOverridesValidationError{
				field:  "Matcher",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldConfigSource_FieldConfigOverridesValidationError{
						field:  fmt.Sprintf("Properties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldConfigSource_FieldConfigOverridesValidationError{
						field:  fmt.Sprintf("Properties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldConfigSource_FieldConfigOverridesValidationError{
					field:  fmt.Sprintf("Properties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FieldConfigSource_FieldConfigOverridesMultiError(errors)
	}

	return nil
}

// FieldConfigSource_FieldConfigOverridesMultiError is an error wrapping
// multiple validation errors returned by
// FieldConfigSource_FieldConfigOverrides.ValidateAll() if the designated
// constraints aren't met.
type FieldConfigSource_FieldConfigOverridesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldConfigSource_FieldConfigOverridesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldConfigSource_FieldConfigOverridesMultiError) AllErrors() []error { return m }

// FieldConfigSource_FieldConfigOverridesValidationError is the validation
// error returned by FieldConfigSource_FieldConfigOverrides.Validate if the
// designated constraints aren't met.
type FieldConfigSource_FieldConfigOverridesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldConfigSource_FieldConfigOverridesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldConfigSource_FieldConfigOverridesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldConfigSource_FieldConfigOverridesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldConfigSource_FieldConfigOverridesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldConfigSource_FieldConfigOverridesValidationError) ErrorName() string {
	return "FieldConfigSource_FieldConfigOverridesValidationError"
}

// Error satisfies the builtin error interface
func (e FieldConfigSource_FieldConfigOverridesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldConfigSource_FieldConfigOverrides.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldConfigSource_FieldConfigOverridesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldConfigSource_FieldConfigOverridesValidationError{}

// Validate checks the field values on GraphPanel_Legend with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GraphPanel_Legend) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GraphPanel_Legend with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GraphPanel_LegendMultiError, or nil if none found.
func (m *GraphPanel_Legend) ValidateAll() error {
	return m.validate(true)
}

func (m *GraphPanel_Legend) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Show

	if m.Sort != nil {
		// no validation rules for Sort
	}

	if m.SortDesc != nil {
		// no validation rules for SortDesc
	}

	if len(errors) > 0 {
		return GraphPanel_LegendMultiError(errors)
	}

	return nil
}

// GraphPanel_LegendMultiError is an error wrapping multiple validation errors
// returned by GraphPanel_Legend.ValidateAll() if the designated constraints
// aren't met.
type GraphPanel_LegendMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GraphPanel_LegendMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GraphPanel_LegendMultiError) AllErrors() []error { return m }

// GraphPanel_LegendValidationError is the validation error returned by
// GraphPanel_Legend.Validate if the designated constraints aren't met.
type GraphPanel_LegendValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GraphPanel_LegendValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GraphPanel_LegendValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GraphPanel_LegendValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GraphPanel_LegendValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GraphPanel_LegendValidationError) ErrorName() string {
	return "GraphPanel_LegendValidationError"
}

// Error satisfies the builtin error interface
func (e GraphPanel_LegendValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGraphPanel_Legend.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GraphPanel_LegendValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GraphPanel_LegendValidationError{}
